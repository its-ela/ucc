El pseudocódigo se estructura en: Cabecera, Bloque de Declaraciones, Inicio, Bloque de Instrucciones y Fin. Incorpora estructuras para ordenamiento simple (como burbuja para listas pequeñas) y cálculo de caminos mínimos (como Dijkstra para grafos).

```markdown
Cabecera
  Algoritmo Procesar_Pedidos_con_Optimizacion_Logistica
  // Descripción: Procesa pedidos con red de zonas, ordenamientos y balanceo de rutas en desarrollo de software.

Bloque de Declaraciones
  Entero M, R, i, j, k, num_zonas
  Real grafo_distancias[num_zonas, num_zonas]  // Matriz de adyacencias (infinito si no conectado)
  Arreglo Pedidos[M]  // Estructura: id, zona, prioridad, valor, total_calculado, viable
  Arreglo Asignaciones[R]  // Listas de pedidos por repartidor
  Booleano procesado[M]
  Real dist_min[num_zonas], distancia_ruta[R], tiempo_ruta[R]
  // Otras vars para precios/stock como en propuestas anteriores

Inicio
  // Entrada: Leer M, R, grafo_distancias, datos de pedidos...
  // Procesar individuales: Validar y calcular totals como antes
  
  // Fase 2: Ordenar pedidos por prioridad y valor (burbuja para simplicidad)
  Para i <- 1 Hasta M-1 Hacer
    Para j <- 1 Hasta M-i Hacer
      Si (Pedidos[j].prioridad > Pedidos[j+1].prioridad) O (Pedidos[j].prioridad = Pedidos[j+1].prioridad Y Pedidos[j].valor < Pedidos[j+1].valor) Entonces
        Intercambiar Pedidos[j] y Pedidos[j+1]
      Fin Si
    Fin Para
  Fin Para
  
  // Fase 3: Asignar pedidos balanceadamente
  Inicializar Asignaciones como vacías
  Para i <- 1 Hasta M Hacer
    Si Pedidos[i].viable Entonces
      // Asignar al repartidor con menor carga actual (valor total)
      Entero rep_min <- 1
      Real carga_min <- Suma_valores(Asignaciones[1])
      Para k <- 2 Hasta R Hacer
        Real carga_k <- Suma_valores(Asignaciones[k])
        Si carga_k < carga_min Entonces
          carga_min <- carga_k
          rep_min <- k
        Fin Si
      Fin Para
      Agregar Pedidos[i] a Asignaciones[rep_min]
    Fin Si
  Fin Para
  
  // Para cada repartidor: Optimizar ruta
  Para k <- 1 Hasta R Hacer
    distancia_ruta[k] <- 0
    Entero zona_actual <- 0  // Almacén
    Arreglo zonas_pedido <- Zonas_de(Asignaciones[k])
    
    Mientras Hay zonas no visitadas Hacer
      // Calcular distancias mínimas desde zona_actual (Dijkstra simplificado)
      Inicializar dist_min[] como Infinito, dist_min[zona_actual] <- 0
      Arreglo no_visitados <- Todas zonas
      Mientras no_visitados no vacío Hacer
        Entero u <- Nodo_min_dist(no_visitados, dist_min)
        Eliminar u de no_visitados
        Para cada vecino v de u Hacer
          Si dist_min[v] > dist_min[u] + grafo_distancias[u,v] Entonces
            dist_min[v] <- dist_min[u] + grafo_distancias[u,v]
          Fin Si
        Fin Para
      Fin Mientras
      
      // Seleccionar siguiente zona pedido no visitada con min dist
      Entero siguiente <- Zona_pedido_min_dist(dist_min, zonas_pedido no visitadas)
      distancia_ruta[k] <- distancia_ruta[k] + dist_min[siguiente]
      zona_actual <- siguiente
      Marcar como visitada
    Fin Mientras
    
    tiempo_ruta[k] <- distancia_ruta[k] / velocidad
    // Verificar si excede max, reasignar si necesario
  Fin Para
  
  // Fase 4 y Salida: Calcular costos, prorratear, mostrar detalles como antes extendido

Fin
```